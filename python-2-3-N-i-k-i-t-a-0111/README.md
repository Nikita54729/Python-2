# Чтение и запись CSV файлов

Так называемый формат **CSV (Comma Separated Values)** является наиболее распространенным форматом импорта и экспорта для электронных таблиц и баз данных. Отсутствие четко определенного стандарта означает, что в данных, создаваемых и потребляемых различными приложениями, часто существуют тонкие различия. Эти различия могут раздражать при обработке файлов CSV из нескольких источников. Тем не менее, хотя разделители и символы кавычек различаются, общий формат достаточно схож, так что можно написать один модуль, который может эффективно манипулировать такими данными, скрывая детали чтения и записи данных от программиста.

Модуль `csv` реализует классы для чтения и записи табличных данных в формате CSV. Это позволяет программистам говорить "записывать данные в формате, предпочтительном для Excel" или "читать данные из файла, сгенерированного Excel", не зная точных деталей формата CSV. Программисты также могут описывать форматы CSV, понятные другим приложениям или определять свои собственные специализированные форматы CSV.

## Чтение и разбор файла CSV

### Синтаксис
```py
import csv

reader = csv.reader(csvfile, dialect='excel', **fmtparams)
```

### Параметры:
- `csvfile` - файловый объект,
- `dialect` - строка с встроенным диалектом из списка `csv.list_dialects()` или объект `Dialect`,
- `fmtparams` - параметры диалекта и форматирования. В качестве ключевых аргументов используйте имена атрибутов объекта `Dialect`:
    - `delimiter=','` - символ, используемый для разделения полей.
    - `quotechar=''` - символ, используемый для кавычек в полях, содержащих специальные символы, такие как разделитель.
    - `escapechar='\\'` - символ, используемый для экранирования разделителя.
    - `quoting=csv.QUOTE_MINIMAL` - определяет, когда должны генерироваться кавычки для полей.
    - `strict=False` - если `True`, то выдает исключение при неправильной разметке CSV.
### Возвращаемое значение:
- объект чтения.
### Описание:

Функция `reader()` модуля `csv` возвращает объект чтения, который будет перебирать строки в данном файле `csvfile`.

Файл `csvfile` может быть любым объектом, который поддерживает протокол итератора и возвращает строку каждый раз, когда вызывается метод `__next__()`. Другими словами, подходят как файловые объекты, так и объекты списка. Если `csvfile` является файловым объектом, его следует открыть с помощью параметра `newline = ''` встроенной функции `open()`.

Можно указать необязательный параметр диалекта `dialect`, который используется для определения набора параметров, специфичных для конкретного диалекта CSV. Это может быть экземпляр подкласса `csv.Dialect` или одна из строк, возвращаемых функцией `csv.list_dialects()`.

Другие необязательные ключевые аргументы `fmtparams` могут быть заданы для переопределения отдельных параметров форматирования в текущем диалекте.

Каждая строка, считанная из файла CSV, возвращается в виде списка строк. По умолчанию автоматическое преобразование типов данных не выполняется. Если указана опция формата `QUOTE_NONNUMERIC`, то в этом случае поля без кавычек преобразуются в числа с плавающей точкой.

### Примеры использования:

```py
import csv

# пишем
with open('eggs.csv', 'w', newline='') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=' ',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

# читаем что получилось
with open('eggs.csv', newline='') as csvfile:
    spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in spamreader:
        print(', '.join(row))

# Spam, Spam, Spam, Spam, Spam, Baked Beans
# Spam, Lovely Spam, Wonderful Spam
```

## Создание и запись данных в файл CSV
### Синтаксис:
```py
import csv

writer = csv.writer(csvfile, dialect='excel', **fmtparams)
```
### Параметры:
- `csvfile` - файловый объект,
- `dialect` - строка с встроенным диалектом из списка `csv.list_dialects()` или объект `Dialect`,
- `fmtparams` - параметры диалекта и форматирования. В качестве ключевых аргументов используйте имена атрибутов объекта `Dialect`:
    - `delimiter=','` - символ, используемый для разделения полей.
    - `quotechar=''` - символ, используемый для кавычек в полях, содержащих специальные символы, такие как разделитель.
    - `escapechar='\\'` - символ, используемый для экранирования разделителя.
    - `quoting=csv.QUOTE_MINIMAL` - определяет, когда должны генерироваться кавычки для полей.
    - `strict=False` - если `True`, то выдает исключение при неправильной разметке CSV.

### Возвращаемое значение:
- объект записи.
### Описание:
Функция `writer()` модуля `csv` возвращает объект записи, отвечающий за преобразование пользовательских данных в строки с разделителями для данного файлового объекта.

`Csvfile` может быть любым объектом с поддержкой метода `file.write()`. Если `csvfile` является файловым объектом, его следует открыть с помощью параметра `newline=''` встроенной функции `open()`.

Можно указать необязательный параметр диалекта `dialect`, который используется для определения набора параметров, специфичных для конкретного диалекта CSV. Это может быть экземпляр подкласса `csv.Dialect` или одна из строк, возвращаемых функцией `csv.list_dialects()`.

Другие необязательные ключевые аргументы `fmtparams` могут быть заданы для переопределения отдельных параметров форматирования в текущем диалекте.

Чтобы максимально упростить взаимодействие с модулями, которые реализуют API БД, значение `None` записывается в виде пустой строки. Хотя это и не обратимое преобразование, оно облегчает вывод значений `NULL` из SQL в файлы CSV без предварительной обработки данных, возвращаемых вызовом `cursor.fetch*`. Все другие не строковые данные перед записью преобразуются в строки, функцией `str()`.


### Примеры использования:
```py
import csv

# пишем
with open('eggs.csv', 'w', newline='') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=' ',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

# читаем что получилось
with open('eggs.csv', newline='') as csvfile:
    spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in spamreader:
        print(', '.join(row))

# Spam, Spam, Spam, Spam, Spam, Baked Beans
# Spam, Lovely Spam, Wonderful Spam
```

## Читать CSV файл как список словарей

### Синтаксис:

```python
import csv

reader = csv.DictReader(f, fieldnames=None, restkey=None,
                        restval=None, dialect='excel', 
                        *args, **kwds)
```

### Параметры:
- `f` - файловый объект,
- `fieldnames=None` - `str`, заголовки полей CSV файла,
- `restkey=None` - заголовок столбца для лишних полей CSV файла,
- `restval=None` - значение поля лишних заголовков,
- `dialect='excel'` - строка с встроенным диалектом из списка `csv.list_dialects()` или объект `Dialect`,
- `*args` - дополнительные аргументы, передаваемые в `reader()`,
- `**kwds` - дополнительные ключевые аргументы, передаваемые в `reader()`.

### Возвращаемое значение:
- объект чтения.

### Описание:
Класс `DictReader()` модуля `csv` создает объект, который работает как обычный `reader()`, но отображает информацию о каждой строке в качестве словаря `dict`, ключи которого задаются необязательным параметром `fieldnames`.

Параметр `fieldnames` является последовательностью. Если имена полей опущены, то в качестве их значений будет использоваться первая строка файлового объекта `f`. Независимо от того, как определены имена полей, словарь сохраняет их первоначальный порядок.

Если в строке CSV файла `f` больше полей, чем имен полей `fieldnames`, оставшиеся данные помещаются в список и сохраняются с именем поля, заданным параметром `restkey` - по умолчанию `None`.

Если в непустой строке CSV файлового объекта `f` меньше полей, чем имен полей `fieldnames`, пропущенные значения заполняются значением `restval` - по умолчанию `None`.

Все остальные необязательные аргументы `*args` или ключевые аргументы `**kwds` передаются в базовый экземпляр `reader()`.

### Примеры использования:

```python
import csv

# сначала запишем файл 'names.csv', который 
# потом прочитаем как список словарей
with open('names.csv', 'w', newline='') as csvfile:
    fieldnames = ['first_name', 'last_name']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})
# 13
# 13
# 16

# читаем CSV файл как список словарей, ключи 
# которого заданы первой строкой файла 'names.csv'
with open('names.csv', newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        print(row['first_name'], row['last_name'])

# Eric Idle
# John Cleese
>>> print(row)
# {'first_name': 'John', 'last_name': 'Cleese'}
```

## Записать CSV файл как список словарей
### Синтаксис:
```python
import csv

writer = csv.DictWriter(f, fieldnames, restval='', 
                        extrasaction='raise', dialect='excel', 
                        *args, **kwds)
```
### Параметры:
- `f` - файловый объект,
- `fieldnames` - `str`, заголовки полей CSV файла,
- `restval=''` - значение поля для лишних/отсутствующих заголовков,
- `extrasaction='raise'` - значение отсутствующего ключа имени поля,
- `dialect='excel'` - строка с встроенным диалектом из списка `csv.list_dialects()` или объект `Dialect`,
- `*args` - дополнительные аргументы, передаваемые в `writer()`,
- `**kwds` - дополнительные ключевые аргументы, передаваемые в `writer()`.
### Возвращаемое значение:
- объект записи.
### Описание:
Класс `DictWriter()` модуля `csv` создает объект, который работает как `csv.writer()`, но позволяет передавать строку с данными на запись как словарь, ключи которой задаются необязательным параметром `fieldnames`.

Параметр `fieldnames` представляет собой последовательность ключей, определяющих порядок значений в словаре, в котором метод `writer.writerow()` записывает данные в файловый объект `f`.

Необязательный параметр `restval` указывает значение, которое будет записано, если в словаре отсутствует ключ в именах полей.

Если словарь, переданный методу `writer.writerow()` , содержит ключ, не найденный в именах полей `fieldnames`, необязательный параметр `extrasaction` указывает, какое действие предпринять.

- Если `extrasaction` установлено значение `'raise'` - значение по умолчанию, то поднимается исключение `ValueError`.
- Если `extrasaction` установлено `'ignore'`, дополнительные значения в словаре игнорируются.

Любые другие необязательные аргументы `*args` или ключевые аргументы `**kwds` передаются базовому экземпляру `csv.writer()`.

Обратите внимание, что в отличие от класса `csv.DictReader()`, аргумент `fieldnames` (заголовки полей CSV файла) класса `csv.DictWriter` является обязательным.

### Примеры использования:

```python
import csv

with open('names.csv', 'w', newline='') as csvfile:
    fieldnames = ['first_name', 'last_name']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})
# 13
# 13
# 16

# теперь читаем, что получилось
with open('names.csv', newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        print(row['first_name'], row['last_name'])

# Baked Beans
# Lovely Spam
# Wonderful Spam
```